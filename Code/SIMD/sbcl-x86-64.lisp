(in-package :one-more-re-nightmare)

(defun find-op (name)
  (or (find-symbol (format nil "V-~a~d" name *bits*)
                   ':one-more-re-nightmare.vector-primops)
      (error "No primop named ~a" name)))

;; AVX2 is a pile of stink and only has instructions for signed
;; comparisons. So, in order to fake an unsigned comparison, we
;; subtract #x80 from everything.

(defun find-8-bit-broadcast (n)
  (find-broadcast (mod (- n #x80) #x100)))
(defvar *swizzled-name*)
(defun swizzle-8-bits ()
  (or *swizzled-name*
      (setf *swizzled-name* (make-symbol "SWIZZLE"))))

(defun translate-scalar-code (variable code)
  (let* ((*swizzled-name* nil)
         (translated (%translate-scalar-code code)))
    (if (null *swizzled-name*)
        translated
        `(let ((,*swizzled-name*
                 (one-more-re-nightmare.vector-primops:v8- ,variable ,(find-broadcast #x80))))
           ,translated))))

(trivia:defun-ematch %translate-scalar-code (code)
  "Translate some 'scalar' code generated by MAKE-TEST-FORM into a vectorised computation."
  ('t   :always)
  ('nil :never)
  ;; All the Boolean operators just map over their arguments.
  ((list 'not thing)
   `(,(find-op "NOT")
     ,(%translate-scalar-code thing)))
  ((list* 'or things)
   (reduce (lambda (a b) `(,(find-op "OR") ,a ,b))
           (mapcar #'%translate-scalar-code things)))
  ;; Ditto for = really.
  ((list '= value variable)
   ;; Note that = works the same if it's signed or not; it's only >
   ;; that requires more effort
   `(,(ecase *bits*
        (32 'one-more-re-nightmare.vector-primops:v32=)
        (8 'one-more-re-nightmare.vector-primops:v8=))
     ,(find-broadcast value) ,variable))
  ;; Generating good code for <= is tricky though. Whoever designed
  ;; SSE2 and AVX2 decided that just having = and > were good enough,
  ;; so we need an efficient implementation of ≤ from those.
  ((list '<= 0 value high)
   ;; No lower bounds here. Note that X ≤ N ⇔ N + 1 > X
   (ecase *bits*
     (32 `(one-more-re-nightmare.vector-primops:v32> ,(find-broadcast (1+ high)) ,value))
     (8 `(one-more-re-nightmare.vector-primops:v8> ,(find-8-bit-broadcast (1+ high)) ,value))))
  ((list '<= low value high)
   ;; Similarly, N ≤ X ⇔ X > N - 1
   (ecase *bits*
     (32
      `(one-more-re-nightmare.vector-primops:v-and32
        ;; Similarly, N ≤ X ⇔ X > N - 1
        (one-more-re-nightmare.vector-primops:v32> ,value ,(find-broadcast (1- low)))
        (one-more-re-nightmare.vector-primops:v32> ,(find-broadcast (1+ high)) ,value)))
     (8
      `(one-more-re-nightmare.vector-primops:v-and8
        (one-more-re-nightmare.vector-primops:v8> ,(swizzle-8-bits)
                                                  ,(find-8-bit-broadcast (1- low)))
        (one-more-re-nightmare.vector-primops:v8> ,(find-8-bit-broadcast (1+ high))
                                                  ,(swizzle-8-bits)))))))

(defmacro define-boring-vop (name args result &body generator)
  `(progn
     (sb-vm::define-vop (,name)
       (:translate ,name)
       (:policy :fast-safe)
       (:args ,@(loop for (name nil . rest) in args
                      collect (cons name rest)))
       (:arg-types ,@(mapcar #'second args))
       (:results (,(first result) ,@(rest (rest result))))
       (:result-types ,(second result))
       (:generator 0 ,@generator))))

(defmacro define-op (name bits args instruction-name)
  (let ((primitive-type (ecase bits
                          (8 'sb-vm::simd-pack-256-ub8)
                          (32 'sb-vm::simd-pack-256-ub32))))
    `(progn
       (sb-c:defknown ,name
           ,(loop for nil in args collect `(sb-ext:simd-pack-256 (unsigned-byte ,bits)))
           (sb-ext:simd-pack-256 (unsigned-byte ,bits))
           (sb-c:foldable sb-c:flushable sb-c:movable)
         :overwrite-fndb-silently t)
       (define-boring-vop ,name
           ,(loop for arg in args
                  collect `(,arg ,primitive-type :scs (sb-vm::int-avx2-reg)))
           (result ,primitive-type :scs (sb-vm::int-avx2-reg))
         (sb-vm::inst ,instruction-name result ,@args)))))

(defun one-more-re-nightmare.vector-primops:all-of (variables)
  (reduce (lambda (a b) `(,(find-op "AND") ,a ,b))
          variables))

(defconstant one-more-re-nightmare.vector-primops:+v-length+ 256)

(in-package :sb-vm)

;;;; Boolean operations

(one-more-re-nightmare::define-op
    one-more-re-nightmare.vector-primops:v-and8 8 (a b) vpand)
(one-more-re-nightmare::define-op
    one-more-re-nightmare.vector-primops:v-and32 32 (a b) vpand)

(one-more-re-nightmare::define-op
    one-more-re-nightmare.vector-primops:v-or8 8 (a b) vpor)
(one-more-re-nightmare::define-op
    one-more-re-nightmare.vector-primops:v-or32 32 (a b) vpor)

(macrolet ((frob (name bits arg-type)
             `(progn
                (defknown ,name
                    ((simd-pack-256 (unsigned-byte ,bits)))
                    (simd-pack-256 (unsigned-byte ,bits))
                    (foldable flushable movable)
                  :overwrite-fndb-silently t)
                (define-vop (,name)
                  (:translate ,name)
                  (:policy :fast-safe)
                  (:args (value :scs (int-avx2-reg)))
                  (:arg-types ,arg-type)
                  (:results (result :scs (int-avx2-reg)))
                  (:result-types ,arg-type)
                  (:temporary (:sc int-avx2-reg) ones)
                  (:generator 0
                    (inst vpcmpeqd ones ones ones)      ; get all 1s
                    (inst vpxor result ones value)))))) ; 1111... (+) A = ¬A
  (frob one-more-re-nightmare.vector-primops:v-not8 8 simd-pack-256-ub8)
  (frob one-more-re-nightmare.vector-primops:v-not32 32 simd-pack-256-ub32))

;;;; Comparisons

;; This is a signed comparison, but as there are fewer than 2³¹
;; Unicode characters, no one needs to know that.
(one-more-re-nightmare::define-op
    one-more-re-nightmare.vector-primops:v32> 32 (a b) vpcmpgtd)

;; We do need to know that this is a signed comparison, since we do
;; want to target (UNSIGNED-BYTE 8) too, and we handle it above.
(one-more-re-nightmare::define-op
    one-more-re-nightmare.vector-primops:v8> 8 (a b) vpcmpgtb)

(one-more-re-nightmare::define-op
    one-more-re-nightmare.vector-primops:v32= 32 (a b) vpcmpeqd)

(one-more-re-nightmare::define-op
    one-more-re-nightmare.vector-primops:v8= 8 (a b) vpcmpeqb)

(one-more-re-nightmare::define-op
    one-more-re-nightmare.vector-primops:v8- 8 (a b) vpsubb)

;;;; Broadcasts

(defknown one-more-re-nightmare.vector-primops:v-broadcast32
    ((unsigned-byte 32))
    (simd-pack-256 (unsigned-byte 32))
    ;; Not constant folding, because loading a folded broadcast is
    ;; slower than reproducing it again.
    (flushable movable)
  :overwrite-fndb-silently t)

(one-more-re-nightmare::define-boring-vop
    one-more-re-nightmare.vector-primops:v-broadcast32
    ((integer unsigned-num :scs (unsigned-reg)))
    (result simd-pack-256-ub32 :scs (int-avx2-reg))
  (inst movq result integer)
  (inst vpbroadcastd result result))

(defknown one-more-re-nightmare.vector-primops:v-broadcast8
    ((unsigned-byte 8))
    (simd-pack-256 (unsigned-byte 8))
    (flushable movable)
  :overwrite-fndb-silently t)

(one-more-re-nightmare::define-boring-vop
    one-more-re-nightmare.vector-primops:v-broadcast8
    ((integer unsigned-num :scs (unsigned-reg)))
    (result simd-pack-256-ub8 :scs (int-avx2-reg))
  (inst movq result integer)
  (inst vpbroadcastb result result))

;;;; Move mask

(defknown one-more-re-nightmare.vector-primops:v-movemask32
    ((simd-pack-256 (unsigned-byte 32)))
    (unsigned-byte 8)
    (flushable movable)
  :overwrite-fndb-silently t)

(one-more-re-nightmare::define-boring-vop
    one-more-re-nightmare.vector-primops:v-movemask32
    ((pack simd-pack-256-ub32 :scs (int-avx2-reg)))
    (result unsigned-num :scs (unsigned-reg))
  (inst vmovmskps result pack))

(defknown one-more-re-nightmare.vector-primops:v-movemask8
    ((simd-pack-256 (unsigned-byte 8)))
    (unsigned-byte 32)
    (flushable movable)
  :overwrite-fndb-silently t)

(one-more-re-nightmare::define-boring-vop
    one-more-re-nightmare.vector-primops:v-movemask8
    ((pack simd-pack-256-ub8 :scs (int-avx2-reg)))
    (result unsigned-num :scs (unsigned-reg))
  (inst vpmovmskb result pack))

;;;; Load

(defknown one-more-re-nightmare.vector-primops:v-load32
    ((simple-array character 1) sb-int:index)
    (simd-pack-256 (unsigned-byte 32))
    (foldable flushable movable)
  :overwrite-fndb-silently t)

(one-more-re-nightmare::define-boring-vop
    one-more-re-nightmare.vector-primops:v-load32
    ((string simple-character-string :scs (descriptor-reg))
     (index tagged-num :scs (any-reg)))
    (result simd-pack-256-ub32 :scs (int-avx2-reg))
  (inst vmovdqu result
        (ea (- (* vector-data-offset n-word-bytes)
               other-pointer-lowtag)
            ;; Characters are 4 bytes, fixnums have a trailing 0 so
            ;; just multiply by 2.
            string index 2)))

(defknown one-more-re-nightmare.vector-primops:v-load8
    ((simple-array base-char 1) sb-int:index)
    (simd-pack-256 (unsigned-byte 8))
    (foldable flushable movable)
  :overwrite-fndb-silently t)

(one-more-re-nightmare::define-boring-vop
    one-more-re-nightmare.vector-primops:v-load8
    ((string simple-base-string :scs (descriptor-reg))
     (index unsigned-num :scs (unsigned-reg)))
    (result simd-pack-256-ub8 :scs (int-avx2-reg))
  (inst vmovdqu result
        (ea (- (* vector-data-offset n-word-bytes)
               other-pointer-lowtag)
            string index 1)))

;;;; Find first set

(defknown one-more-re-nightmare.vector-primops:find-first-set
    ((unsigned-byte 64))
    (mod 64)
    (foldable flushable movable)
  :overwrite-fndb-silently t)

(one-more-re-nightmare::define-boring-vop
    one-more-re-nightmare.vector-primops:find-first-set
    ((integer unsigned-num :scs (unsigned-reg)))
    (result unsigned-num :scs (unsigned-reg))
  (inst bsf result integer))
